Ramda
=====

----------------------------------------------------
> Type:
    - is
    - isNil
    - propIs
    - type
----------------------------------------------------
> Math:
    - add
    - dec
    - divide
    - inc
    - mathMod
    - mean
    - median
    - modulo
    - multiply
    - negate
    - product
    - subtract
    - sum
----------------------------------------------------
> Logic:
    - allPass
    - and
    - anyPass
    - both
    - complement
    - cond
    - defaultTo
    - either
    - ifElse
    - isEmpty
    - not
    - or
    - pathSatisfies
    - propSatisfies
    - unless
    - until
    - when
----------------------------------------------------
> String:
    - match
    - replace
    - split
    - test
    - toLower
    - toString
    - toUpper
    - trim
----------------------------------------------------
> Object:
    - assoc
    - assocPath
    - clone
    - dissoc
    - dissocPath
    - eqProps
    - evolve
    - forEachObjIndexed
    - has
    - hasIn
    - hasPath
    - invert
    - invertObj
    - keys
    - keysIn
    - lens
    - lensIndex
    - lensPath
    - lensProp
    - mapObjIndexed
    - merge
    - mergeDeepLeft
    - mergeDeepRight
    - mergeDeepWith
    - mergeDeepWithKey
    - mergeLeft
    - mergeRight
    - mergeWith
    - mergeWithKey
    - objOf
    - omit
    - over
    - path
    - pathOr
    - pick
    - pickAll
    - pickBy
    - project
    - prop
    - propOr
    - props
    - set
    - toPairs
    - toPairsIn
    - values
    - valuesIn
    - view
    - where
    - whereEq
----------------------------------------------------
> List === Array:
    - adjust
    - all
    - any
    - aperture
    - append
    - chain
    - concat
    - contains
    - drop
    - dropLast
    - dropLastWhile
    - dropRepeats
    - dropRepeatsWith
    - dropWhile
    - endsWith
    - filter
    - find
    - findIndex
    - findLast
    - findLastIndex
    - flatten
    - forEach
    - fromPairs
    - groupBy
    - groupWith
    - head
    - includes
    - indexBy
    - indexOf
    - init
    - insert
    - insertAll
    - intersperse
    - into
    - join
    - last
    - lastIndexOf
    - length
    - map
    - mapAccum
    - mapAccumRight
    - mergeAll
    - move
    - none
    - nth
    - pair
    - partition
    - pluck
    - prepend
    - range
    - reduce
    - reduceBy
    - reduced
    - reduceRight
    - reduceWhile
    - reject
    - remove
    - repeat
    - reverse
    - scan
    - sequence
    - slice
    - sort
    - splitAt
    - splitEvery
    - splitWhen
    - startsWith
    - tail
    - take
    - takeLast
    - takeLastWhile
    - takeWhile
    - times
    - transduce
    - transpose
    - traverse
    - unfold
    - uniq
    - uniqBy
    - uniqWith
    - unnest
    - update
    - without
    - xprod
    - zip
    - zipObj
    - zipWith
----------------------------------------------------
> Function
    - __
    - addIndex
    - always
    - ap
    - apply
    - applySpec
    - applyTo
    - ascend
    - binary
    - bind
    - call
    - comparator
    - compose
    - composeK
    - composeP
    - composeWith
    - construct
    - constructN
    - converge
    - curry
    - curryN
    - descend
    - empty
    - F
    - flip
    - identity
    - invoker
    - juxt
    - lift
    - liftN
    - memoizeWith
    - nAry
    - nthArg
    - o
    - of
    - once
    - otherwise
    - partial
    - partialRight
    - pipe
    - pipeK
    - pipeP
    - pipeWith
    - T
    - tap
    - then
    - thunkify
    - tryCatch
    - unapply
    - unary
    - uncurryN
    - useWith
----------------------------------------------------
> Relation:
    - clamp
    - countBy
    - difference
    - differenceWith
    - eqBy
    - equals
    - gt
    - gte
    - identical
    - innerJoin
    - intersection
    - lt
    - lte
    - max
    - maxBy
    - min
    - minBy
    - pathEq
    - propEq
    - sortBy
    - sortWith
    - symmetricDifference
    - symmetricDifferenceWith
    - union
    - unionWith
----------------------------------------------------

{ F: [Function: F],
  T: [Function: T],
  __: { '@@functional/placeholder': true },
  add: [Function: f2],
  addIndex: [Function: f1],
  adjust: [Function: f3],
  all: [Function: f2],
  allPass: [Function: f1],
  always: [Function: f1],
  and: [Function: f2],
  any: [Function: f2],
  anyPass: [Function: f1],
  ap: [Function: f2],
  aperture: [Function: f2],
  append: [Function: f2],
  apply: [Function: f2],
  applySpec: [Function: f1],
  applyTo: [Function: f2],
  ascend: [Function: f3],
  assoc: [Function: f3],
  assocPath: [Function: f3],
  binary: [Function: f1],
  bind: [Function: f2],
  both: [Function: f2],
  call: [Function: f1],
  chain: [Function: f2],
  clamp: [Function: f3],
  clone: [Function: f1],
  comparator: [Function: f1],
  complement: [Function: f1],
  compose: [Function: compose],
  composeK: [Function: composeK],
  composeP: [Function: composeP],
  composeWith: [Function: f2],
  concat: [Function: f2],
  cond: [Function: f1],
  construct: [Function: f1],
  constructN: [Function: f2],
  contains: [Function: f2],
  converge: [Function: f2],
  countBy: [Function],
  curry: [Function: f1],
  curryN: [Function: f2],
  dec: [Function: f1],
  defaultTo: [Function: f2],
  descend: [Function: f3],
  difference: [Function: f2],
  differenceWith: [Function: f3],
  dissoc: [Function: f2],
  dissocPath: [Function: f2],
  divide: [Function: f2],
  drop: [Function: f2],
  dropLast: [Function: f2],
  dropLastWhile: [Function: f2],
  dropRepeats: [Function: f1],
  dropRepeatsWith: [Function: f2],
  dropWhile: [Function: f2],
  either: [Function: f2],
  empty: [Function: f1],
  endsWith: [Function: f2],
  eqBy: [Function: f3],
  eqProps: [Function: f3],
  equals: [Function: f2],
  evolve: [Function: f2],
  filter: [Function: f2],
  find: [Function: f2],
  findIndex: [Function: f2],
  findLast: [Function: f2],
  findLastIndex: [Function: f2],
  flatten: [Function: f1],
  flip: [Function: f1],
  forEach: [Function: f2],
  forEachObjIndexed: [Function: f2],
  fromPairs: [Function: f1],
  groupBy: [Function: f2],
  groupWith: [Function: f2],
  gt: [Function: f2],
  gte: [Function: f2],
  has: [Function: f2],
  hasIn: [Function: f2],
  hasPath: [Function: f2],
  head: [Function: f1],
  identical: [Function: f2],
  identity: [Function: f1],
  ifElse: [Function: f3],
  inc: [Function: f1],
  includes: [Function: f2],
  indexBy: [Function],
  indexOf: [Function: f2],
  init: [Function: f1],
  innerJoin: [Function: f3],
  insert: [Function: f3],
  insertAll: [Function: f3],
  intersection: [Function: f2],
  intersperse: [Function: f2],
  into: [Function: f3],
  invert: [Function: f1],
  invertObj: [Function: f1],
  invoker: [Function: f2],
  is: [Function: f2],
  isEmpty: [Function: f1],
  isNil: [Function: f1],
  join: [Function],
  juxt: [Function: f1],
  keys: [Function: f1],
  keysIn: [Function: f1],
  last: [Function: f1],
  lastIndexOf: [Function: f2],
  length: [Function: f1],
  lens: [Function: f2],
  lensIndex: [Function: f1],
  lensPath: [Function: f1],
  lensProp: [Function: f1],
  lift: [Function: f1],
  liftN: [Function: f2],
  lt: [Function: f2],
  lte: [Function: f2],
  map: [Function: f2],
  mapAccum: [Function: f3],
  mapAccumRight: [Function: f3],
  mapObjIndexed: [Function: f2],
  match: [Function: f2],
  mathMod: [Function: f2],
  max: [Function: f2],
  maxBy: [Function: f3],
  mean: [Function: f1],
  median: [Function: f1],
  memoizeWith: [Function: f2],
  merge: [Function: f2],
  mergeAll: [Function: f1],
  mergeDeepLeft: [Function: f2],
  mergeDeepRight: [Function: f2],
  mergeDeepWith: [Function: f3],
  mergeDeepWithKey: [Function: f3],
  mergeLeft: [Function: f2],
  mergeRight: [Function: f2],
  mergeWith: [Function: f3],
  mergeWithKey: [Function: f3],
  min: [Function: f2],
  minBy: [Function: f3],
  modulo: [Function: f2],
  move: [Function: f3],
  multiply: [Function: f2],
  nAry: [Function: f2],
  negate: [Function: f1],
  none: [Function: f2],
  not: [Function: f1],
  nth: [Function: f2],
  nthArg: [Function: f1],
  o: [Function: f3],
  objOf: [Function: f2],
  of: [Function: f1],
  omit: [Function: f2],
  once: [Function: f1],
  or: [Function: f2],
  otherwise: [Function: f2],
  over: [Function: f3],
  pair: [Function: f2],
  partial: [Function: f2],
  partialRight: [Function: f2],
  partition: [Function],
  path: [Function: f2],
  pathEq: [Function: f3],
  pathOr: [Function: f3],
  pathSatisfies: [Function: f3],
  pick: [Function: f2],
  pickAll: [Function: f2],
  pickBy: [Function: f2],
  pipe: [Function: pipe],
  pipeK: [Function: pipeK],
  pipeP: [Function: pipeP],
  pipeWith: [Function: f2],
  pluck: [Function: f2],
  prepend: [Function: f2],
  product: [Function: f1],
  project: [Function],
  prop: [Function: f2],
  propEq: [Function: f3],
  propIs: [Function: f3],
  propOr: [Function: f3],
  propSatisfies: [Function: f3],
  props: [Function: f2],
  range: [Function: f2],
  reduce: [Function: f3],
  reduceBy: [Function],
  reduceRight: [Function: f3],
  reduceWhile: [Function],
  reduced: [Function: f1],
  reject: [Function: f2],
  remove: [Function: f3],
  repeat: [Function: f2],
  replace: [Function: f3],
  reverse: [Function: f1],
  scan: [Function: f3],
  sequence: [Function: f2],
  set: [Function: f3],
  slice: [Function: f3],
  sort: [Function: f2],
  sortBy: [Function: f2],
  sortWith: [Function: f2],
  split: [Function],
  splitAt: [Function: f2],
  splitEvery: [Function: f2],
  splitWhen: [Function: f2],
  startsWith: [Function: f2],
  subtract: [Function: f2],
  sum: [Function: f1],
  symmetricDifference: [Function: f2],
  symmetricDifferenceWith: [Function: f3],
  tail: [Function: f1],
  take: [Function: f2],
  takeLast: [Function: f2],
  takeLastWhile: [Function: f2],
  takeWhile: [Function: f2],
  tap: [Function: f2],
  test: [Function: f2],
  then: [Function: f2],
  times: [Function: f2],
  toLower: [Function: f1],
  toPairs: [Function: f1],
  toPairsIn: [Function: f1],
  toString: [Function: f1],
  toUpper: [Function: f1],
  transduce: [Function],
  transpose: [Function: f1],
  traverse: [Function: f3],
  trim: [Function: f1],
  tryCatch: [Function: f2],
  type: [Function: f1],
  unapply: [Function: f1],
  unary: [Function: f1],
  uncurryN: [Function: f2],
  unfold: [Function: f2],
  union: [Function: f2],
  unionWith: [Function: f3],
  uniq: [Function: f1],
  uniqBy: [Function: f2],
  uniqWith: [Function: f2],
  unless: [Function: f3],
  unnest: [Function: f1],
  until: [Function: f3],
  update: [Function: f3],
  useWith: [Function: f2],
  values: [Function: f1],
  valuesIn: [Function: f1],
  view: [Function: f2],
  when: [Function: f3],
  where: [Function: f2],
  whereEq: [Function: f2],
  without: [Function: f2],
  xprod: [Function: f2],
  zip: [Function: f2],
  zipObj: [Function: f2],
  zipWith: [Function: f3],
  thunkify: [Function: f1] }

----------------------------------------------------------------------------------------------
> Alternatives:

- Underscore.js
- Lodash.js ( fork of underscore.js )
- ramda.js ( Another fork of underscore, claims to be much faster than underscore and lodash)
- bacon.js
- functional.js




a **Functor** is something that you can **Map**.
> all of these are functors because we can map them:
    - Array
    - Tree
    - Stream
    - Promise
a **Monad** is **Functor** that you can **FlatMap**.
    - Stream
    - Promise




Mapper: function that performed at every element in collection
Collection: Array | String | Object


flatMap === bind "in Hsskell" === chain "in some langs"





----------------------------------------------------------------------------------------------------------------------
SKI Combinator Calculus
S: Substitution Operator
K: Const Function
I: Identify Function



identify()
always()

F()
T()


map
chain=== flattenMap






flatten -> remove all level from chain
unnest -> remove one level from chain


# when a data structure implements map it exposes a slot in which we can stick a function that will allow us to have that function operate on the individual items in the data structure even though it's not specifically built for that which saves us from a lot of glue logic that would otherwise be needed to so all of these functions together




- Any language that has functions in it, you're doing functional programming.
- Functions entered programming languages with FORTRAN II in 1958.

- FORTRAN was developed before lowercase was invented, so everything was in uppercase.
[laughter] But other than that, it looks the same.

One of the stupid things in FORTRAN was you didn't have to declare your variables.
Variables were implicit.
But fortunately they were scoped to the function, they weren't implicit globals like JavaScript does, which is way stupider.

If you wanted them to be global then you would specify them in a common statement.
You didn't have to specify their types, even though it's a typed language.
The convention they had was if the variable starts with I, J, K, L, M, or N, it's an integer.
Otherwise it's floating point.
[laughter]

The way you returned a value from a function, the function had a name and you would assign
to that name, and then when you hit the return statement whatever value you last assigned
to the name of the function, that was what was returned.
This was also before curly braces were invented, so the way you ended the function was by saying
name.
This was highly influential.
All languages have some version of this, some with different syntax, some with different
key words.
There have been func, procedure, proc, subroutine, Lambda.
Lots of other things.



That's one sense of functional programming.
The other is sometimes called pure functional programming.
The difference is in pure functional programming, it's mathematical.
You're thinking about functions as mathematical functions, which is very different than a
subroutine that returns a value which is what we do in our other languages.





SKI Combinator Calculus
S: Substitution Operator
K: Const Function
I: Identify Function



identify()
F()
T()


map
chain=== flattenMap



flatten -> remove all level from chain
unnest -> remove one level from chain